\section{Communications}
Communications between the arduino and computer are done over the supplied RF link. The frequency is set to the group frequency specified. Further the optional encryption was enabled and the PAN ID set to 6810.

Data is send to and from the devices in packets, the basic form of a packet is: \\
`\verb$<target><source><data><checksum>\r\n$'\\ 
\texttt{<target>} and \texttt{<source>} are the ASCII character `1' for the group 11 robot, the ASCII character `2' for the group 12 robot, and the ASCII character `c' for the computer. For robot to computer messages, the targets `d' and `e' are also valid, used to send debug and error messages respectively. \texttt{<data>} is the base64 encoded binary message, and \texttt{<checksum>} a checksum of the preceding message.  The base64 encoding
does not use padding bytes, but is otherwise standard.

The checksum consists of 2 characters, which are calculated as the checksum of all characters at even (starting 0) and odd indices respectively, including \texttt{<target>} and \texttt{<source>}. These checksums are done by retrieving the value from 0-63 of the character in base64 encoding, XORing these together. 
The resulting value from 0-63 is then encoded back into a base64 character.

For example, the checksum of `\texttt{dt6bas2}' is `\texttt{La}'.

Devices ignores all packets not addressed to it, as well as malformed packets (including incorrect checksum). Upon receipt of a packet, the device sends an acknowledgement. An acknowledgement packet has the form `\verb%<target>$<checksum>\r\n%'. An acknowledgement packet is not itself acknowledged.

The computer side will resend packets which have not received an acknowledgement. The Arduino side does not, and discards packets which are longer than the internal buffer (60 bytes). To prevent flooding, only the previously sent packet is resent. This suits the application well, as previously sent packets contain instructions to the robot which are superseded by the more recent one.

\subsection{Bytecode}

The data received by the Arduino from the controller is interpreted as a sequence of bytecode instructions. Each instruction starts with a single byte opcode specifying the instruction itself, followed by a number of bytes for the argument of the instruction. The number of bytes the argument used depend on the instruction itself (See the arguments column below; An instruction with a single \verb$uint16_t$ argument will take 2 bytes for its arguments).

%\noindent
\begin{table}[H]

\begin{tabularx}{\textwidth}{rlX}
    Opcode & Arguments & Description \\
    \hline
    \texttt{0x00} & time (\texttt{uint16\_t}) &
        Waits for the given time \\
    \texttt{0x01} & time (\texttt{uint16\_t}) &
        Brakes for the given time \\
    \texttt{0x02} & distance (\texttt{int16\_t}) &
        Moves the given distance to the right (or neg. left) \\
    \texttt{0x03} & angle (\texttt{int16\_t}) &
        Spins the given (possibly negative) angle clockwise \\
    \texttt{0x04} & time (\texttt{uint16\_t}) &
        Activates the kicker for the given time \\
    \texttt{0x06} & \textit{none} &
        Opens the grabbers \\
    \texttt{0x07} & \textit{none} &
        Closes the grabbers \\
    \texttt{0x09} & speed (\texttt{uint8\_t}) &
        Sets the global speed modifier (value from 0-255) \\
%    \texttt{0x0a} & distance (\texttt{int16_t}), radius (\texttt{int16_t}) &
%        Moves the specified distance on an arc with the given radius in front
%        of the robot \\
\end{tabularx}
\end{table}

Times are given in milliseconds, distances in mm and angles in minutes.  The arguments are read directly from instruction sequence memory as the given type, and the next command starts after the current one finishes. Numbers are encoded in little-endian.

The instructions, when received, are compiled by the Arduino into low-level commands, and inserted at the earliest possible point in the low-level command queue.

\subsection{Low-Level Commands}

The arduino internally maintains a queue of low-level commands which capture what the robot is currently doing. Once a command finishes, the Arduino immediately moves on to the next. Structurally, low-level commands work similarly to high-level ones. They start with an opcode, depending on which some arguments may follow. The available low-level commands are:

\begin{table}[H]
\begin{tabularx}{\textwidth}{rlX}
    Opcode & Arguments & Description \\
    \hline
    \texttt{0x00} & time (\texttt{uint16\_t}) &
        Waits for the given time \\
    \texttt{0x01} & time (\texttt{uint16\_t}) &
        Brakes for the given time \\
    \texttt{0x02} & time (\texttt{uint16\_t}) &
        Opens the grabbers for the given time \\
    \texttt{0x03} & time (\texttt{uint16\_t}) &
        Closes the grabbers slowly for the given time \\
    \texttt{0x04} & time (\texttt{uint16\_t}) &
        Closes the grabbers quickly for the given time \\
    \texttt{0x05} & time (\texttt{uint16\_t}) &
        Activates the kicker for the given time \\
    \texttt{0x08} & distance (\texttt{int16\_t}) &
        Moves right by the given distance \\
    \texttt{0x09} & angle (\texttt{int16\_t}) &
        Spins clockwise by the given angle \\
    \texttt{0x0b} & speed (\texttt{uint8\_t}) &
        Sets the global speed modifier to the given value \\
%    \texttt{0x0c} & distance (\texttt{int16_t}), front wheel weight (\texttt{uint16_t}), back wheel weight (\texttt{uint16_t}) &
%        Moves the given distance, with the speed of the front and back wheels being in the specified proportion (used for arc movement) \\
    \texttt{0x7f} & \textit{none} & Does nothing \\
\end{tabularx}
\end{table}

Further, the most significant bit of a low-level commands opcode signifies if this command is interruptible or not. If it is 1, the command is not interruptible.

The Arduino periodically updates the instruction list to decrease the time argument of the current instruction by the time passed, or, if the instruction is finished, moving onto the next one. If a new command sequence arrives, it is inserted in place of the first interruptible command in the sequence, with this, and all later commands being discarded. This ensures that non-interruptible commands are always run, and are run even if they consist of complex sequences which should not be interrupted. This is also the main reason for a no-op existing; it allows separating multiple sequences of non-interruptible commands.

Instructions setting values relating to the communications test are set immediately, and the Arduino moves on to the next instruction. The send instruction \texttt{0xf2} suspends normal operation and executes a writing the buffer to the I$^2$C port with the previously set delay.