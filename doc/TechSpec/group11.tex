\documentclass[a4paper]{scrartcl}
\usepackage{tabularx}
\author{Thomas Kerber}
\title{Technical Specification}
\subtitle{Group 11}

\begin{document}
\maketitle
\section{Communications}

Communications between the arduino and computer are done over the supplied RF
link. The frequency is set to the group frequency specified. Further the
optional encryption was enabled and the PAN ID set to 6810.

Data is send to and from the devices in packets, the basic form of a packet is
`\verb$<target><source><data><checksum>\r\n$'. \texttt{<target>} and
\texttt{<source>} are the ASCII character `1' for the group11 robot, and the
ASCII character `c' for the computer. For robot to computer messages, the
targets `d' and `e' are also valid, used to send debug and error messages
respectively. \texttt{<data>} is the base64 encoded binary message, and
\texttt{<checksum>} a checksum of the preceding message.  The base64 encoding
does not use padding bytes, but is otherwise standard.

The checksum consists of 2 characters, which are calculated as the checksum of
all characters at even (starting 0) and odd indicies respectively, including
\texttt{<target>} and \texttt{<source>}. These checksums are done by retrieving
the value from 0-63 of the character in base64 encoding, XORing these together.
The resulting value from 0-63 is then encoded back into a base64 character.

For example, the checksum of `\texttt{dt6bas2}' is `\texttt{La}'.

Devices ignores all packets not addressed to it, as well as malformed packets
(including incorrect checksum). Upon receipt of a packet, the device sends an
acknowledgement. An acknowledgement packet has the form
`\verb%<target>$<checksum>\r\n%'. An acknowledgement packet is not itself
acknowledged.

The computer side will resend packets which have not recieved an
acknowledgement. The arduino side does not, and discards packets which are
longer than the internal buffer (60 bytes). To prevent flooding, only the
previously sent packet is resent. This suits the application well, as
previously sent packets contain intructions to the robot which are supersceded
by the more recent one.

\section{Bytecode}

The data recieved by the arduino from the controller is interpreted as a
sequence of bytecode instructions. Each instruction starts with a single byte
opcode specifying the instruction itself, followed by a number of bytes for the
argument of the instruction. The number of bytes the argument used depend on
the instruction itself (See the arguments column below; An instruction with a
single \verb$uint16_t$ argument will take 2 bytes for its arguments).

\begin{tabularx}{\textwidth}{rlX}
    Opcode & Arguments & Description \\
    \hline
    \texttt{0x00} & time (\verb$uint16_t$) &
        Waits for the given time \\
    \texttt{0x01} & time (\verb$uint16_t$) &
        Brakes for the given time \\
    \texttt{0x02} & distance (\verb$int16_t$) &
        Moves the given (possibly negative) distance to the right \\
    \texttt{0x03} & angle (\verb$int16_t$) &
        Spins the given (possibly negative) angle clockwise \\
    \texttt{0x04} & time (\verb$uint16_t$) &
        Activates the kicker for the given time \\
    \texttt{0x06} & \textit{none} &
        Opens the grabbers \\
    \texttt{0x07} & \textit{none} &
        Closes the grabbers \\
    \texttt{0x09} & speed (\verb$uint8_t$) &
        Sets the global speed modifier (value from 0-255) \\
%    \texttt{0x0a} & distance (\verb$int16_t$), radius (\verb$int16_t$) &
%        Moves the specified distance on an arc with the given radius in front
%        of the robot \\
\end{tabularx}

Times are given in milliseconds, distances in mm and angles in minutes.  The
arguments are read directly from instruction sequence memory as the given type,
and the next command starts after the current one finishes. Numbers are encoded
in little-endian.

The instructions, when recieved, are compiled by the arduino into low-level
commands, and inserted at the earliest possible point in the low-level command
queue.

\section{Low-Level Commands}

The arduino internally maintains a queue of low-level commands which capture
what the robot is currently doing. Once a command finishes, the arduino
immediately moves on to the next. Structurally, low-level commands work
similarly to high-level ones. They start with an opcode, depending on which
some arguments may follow. The available low-level commands are:

\begin{tabularx}{\textwidth}{rlX}
    Opcode & Arguments & Description \\
    \texttt{0x00} & time (\verb$uint16_t$) &
        Waits for the given time \\
    \texttt{0x01} & time (\verb$uint16_t$) &
        Brakes for the given time \\
    \texttt{0x02} & time (\verb$uint16_t$) &
        Opens the grabbers for the given time \\
    \texttt{0x03} & time (\verb$uint16_t$) &
        Closes the grabbers slowly for the given time \\
    \texttt{0x04} & time (\verb$uint16_t$) &
        Closes the grabbers quickly for the given time \\
    \texttt{0x05} & time (\verb$uint16_t$) &
        Activates the kicker for the given time \\
    \texttt{0x08} & distance (\verb$int16_t$) &
        Moves right by the given distance \\
    \texttt{0x09} & angle (\verb$int16_t$) &
        Spins clockwise by the given angle \\
    \texttt{0x0b} & speed (\verb$uint8_t$) &
        Sets the global speed modifier to the given value \\
%    \texttt{0x0c} & distance (\verb$int16_t$), front wheel weight (\verb$uint16_t$), back wheel weight (\verb$uint16_t$) &
%        Moves the given distance, with the speed of the front and back wheels being in the specified proportion (used for arc movement) \\
    \texttt{0x7f} & \textit{none} & Does nothing \\
\end{tabularx}

Further, the most significant bit of a low-level commands opcode signifies if this command is interruptable or not. If it is 1, the command is not interruptable.

The arduino periodically updates the instruction list to decrease the time
argument of the current instruction by the time passed, or, if the instruction
is finished, moving onto the next one. If a new command sequence arrives, it is
inserted in place of the first interruptable command in the sequence, with
this, and all later commands being discarded. This ensures that
non-interruptable commands are always run, and are run even if they consist of
complex sequences which should not be interrupted. This is also the main reason
for a no-op existing; it allows seperating multiple sequences of
uninterruptable commands.

Instructions setting values relating to the comms test are set immediately,
and the arduino moves on to the next instruction. The send instruction
\texttt{0xf2} suspends normal operation and executes a writing the buffer to
the I$^2$C port with the previously set delay.

\section{Hardware Notes}

Grabbing the ball effectively is a fine balance of speed. Moving the grabbers
too quickly kicks the ball away. On the other hand, moving too slowly may lead
to missing the ball. Further, the design of the robot means that the ball must
be pushed in sharply to reset the kicker. The balance between these that was
found, is to close the grabbers at a moderate speed, then rapidly open them
part way and rapidly close them again. This resets the kicker, does not kick the ball away in most cases, and is fast enough to be usable.

Kicking the ball is a matter of speed, the faster we can kick, the less time
our opponents have to react. However, in order to kick, the ball must also be
positioned precicely in front of the kicker. To achieve this, the grabbers
rapidly push the ball into position again, correcting any drift from movement.
They they open part-way, just enough for the kicker to kick without the ball
hitting the grabbers. Finally, the grabbers finish opening.

Spinning and moving tends to move the grabbers about. To avoid this, the
grabbers are powered slightly during both of these actions. If the grabbers are
open, they are constantly opening while the robot is moving, albeit very
slowly. Likewise, the grabbers keep closing if they are already closed. For
this purpose, the robot maintains a local state variable for the grabber. It is
worth stating that this is not measured or sensed, so manually moving the
grabbers will confuse the robot.

\end{document}
