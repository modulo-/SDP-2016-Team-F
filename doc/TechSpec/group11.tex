\documentclass[a4paper]{scrartcl}
\usepackage{tabularx}
\author{Thomas Kerber}
\title{Technical Specification}
\subtitle{Group 11}

\begin{document}
\maketitle
\section{Communications}

Communications between the arduino and computer are done over the supplied RF
link. The frequency is set to the group frequency specified. Further the
optional encryption was enabled and the PAN ID set to 6810.

Data is send to and from the devices in packets, the basic form of a packet is
`\verb$<target><source><data><checksum>\r\n$'. \texttt{<target>} and
\texttt{<source>} are the ASCII character `1' for the group11 robot, and the
ASCII character `c' for the computer. \texttt{<data>} is the base64 encoded
binary message, and \texttt{<checksum>} a checksum of the preceding message.
The base64 encoding does not use padding bytes, but is otherwise standard.

The checksum consists of 2 characters, which are calculated as the checksum of
all characters at even (starting 0) and odd indicies respectively, including
\texttt{<target>} and \texttt{<source>}. These checksums are done by retrieving
the value from 0-63 of the character in base64 encoding, XORing these together.
The resulting value from 0-63 is then encoded back into a base64 character.

For example, the checksum of `\texttt{dt6bas2}' is `\texttt{La}'.

Devices ignores all packets not addressed to it, as well as malformed packets
(including incorrect checksum). Upon receipt of a packet, the device sends an
acknowledgement. An acknowledgement packet has the form
`\verb%<target>$<checksum>\r\n%'. An acknowledgement packet is not itself
acknowledged.

The computer side will resend packets which have not recieved an
acknowledgement. The arduino side does not, and discards packets which are
longer than the internal buffer (60 bytes). As of the time of writing, no
precautions are in place to prevent flooding, and care must be taken to avoid
this.

\section{Bytecode}

The data recieved by the arduino from the controller is interpreted as a
sequence of bytecode instructions. Each instruction starts with a single byte
opcode specifying the instruction itself, followed by a number of bytes for the
argument of the instruction. The number of bytes the argument used depend on
the instruction itself (See the arguments column below; An instruction with a
single \verb$uint16_t$ argument will take 2 bytes for its arguments).

\begin{tabularx}{\textwidth}{rlX}
    Opcode & Arguments & Description \\
    \hline
    \texttt{0x00} & time (\verb$uint16_t$) & Waits for
        the given time \\
    \texttt{0x01} & time (\verb$uint16_t$) &
        Retracts the kicker for the given time \\
    \texttt{0x02} & time (\verb$uint16_t$) &
        Extends the kicker for the given time \\
    \texttt{0x03} & time (\verb$uint16_t$) &
        Moves rights for the given time \\
    \texttt{0x04} & time (\verb$uint16_t$) &
        Moves left for the given time \\
    \texttt{0x05} & time (\verb$uint16_t$) &
        Spins counter-clockwise for the given time \\
    \texttt{0x06} & time (\verb$uint16_t$) &
        Spins clockwise for the given time \\
    \texttt{0xf0} & length (\verb$uint8_t$) &
        Sets the length of the comms buffer \\
    \texttt{0xf1} & time (\verb$uint16_t$) &
        Sets the time between each byte sent \\
    \texttt{0xf2} & \textit{none} &
        Writes the comms buffer to the I$^2$C port byte by byte with the given
        delay \\
    \texttt{0x8i} & buf (\verb$uint8_t[25]$) &
        Sets 25 consecutive buffer bytes from the index $25i$ ($0 \le i < 10$)
        \\
\end{tabularx}

All times are given in milliseconds. The arguments are read directly from
instruction sequence as the given type, and the next command starts after the
current one finishes. For example, the command byte sequence \texttt{02 ee 02
00 64 00 01 0e 01} is interpreted as the following sequence of instructions:

\begin{enumerate}
\item Extend the kicker for 750ms.
\item Wait for 100ms.
\item Retract the kicker for 270ms.
\end{enumerate}

The arduino periodically updates the instruction list to decrease the time
argument of the current instruction by the time passed, or, if the instruction
is finished, moving onto the next one.

Instructions setting values relating to the comms test are set immediately,
and the arduino moves on to the next instruction. The send instruction
\texttt{0xf2} suspends normal operation and executes a writing the buffer to
the I$^2$C port with the previously set delay.

\section{Command Shell}

The command shell is a small computer-side shell allowing inputting of commands
which are then converted into a sequence of bytecode instructions. Some of
these map directly to opcodes sent (useful for testing and calibrating, but not
for typical useage), others are converted to the more low-level opcodes. A list
of available commands:

\begin{tabularx}{\textwidth}{llX}
    Name & Arguments & Description \\
    \hline
    \verb$led_on$ & time & Puts the led on (waits) for the given time \\
    \verb$kicker_fwd$ & time & Retracts the kicker for the given time \\
    \verb$kicker_bwd$ & time & Extends the kicker for the given time \\
    \verb$left_t$ & time & Moves left for the given time \\
    \verb$right_t$ & time & Moves right for the given time \\
    \verb$spin_cw_t$ & time & Spins clockwise for the given time \\
    \verb$spin_cc_t$ & time & Spins counter-clockwise for the given time \\
    \verb$kick_t$ & time & Kicks, extending for the given time \\
    \verb$left$ & dist & Moves left the given distance \\
    \verb$right$ & dist & Moves right the given distance \\
    \verb$kick$ & dist & Kicks to the given distance \\
    \verb$spin_cw$ & angle & Spins clockwise the given angle \\
    \verb$spin_cc$ & angle & Spins counter-clockwise the given angle \\
    \verb$mv$ & $x$, $y$, angle & Moves to the displacement, as specified in
        the milestone 1 specifications. \\
    \verb$send_file$ & delay, file & Sends the file to be written over I$^2$C,
        as specified in the milestone 1 specifications. \\
    \verb$exit$ & \textit{none} & Exits the shell \\
\end{tabularx}

A command may look like `\verb$kick 150$'. With the exception of
`\verb$send_file$' and `\verb$exit$', commands can be chained by writing them
in sequence. E.g.  `\texttt{left 100 led\_on 100 right 100}' would move left a
meter, wait 100ms, and move right a meter again. Distances are given in cm,
times in ms and angles in degrees.

The non-time variants of time-based commands (e.g. \verb$left$), calculate a
time using a linear function to convert the distance or angle into a time. The
\verb$mv$ command is move complex, the movement is split into a rotation, a
left/right movement and a second rotation. The values for these three movements
are calculated using basic trigonometry. In order to ensure that motors come to
a rest, a 100ms wait is inserted between each part.

The \verb$send_file$ first reads the given file. It then sends a packet setting
the buffer length, and one setting the delay as specified. Then, the file is
split into chunks of 25 bytes, each sent over in a single packet. The last
chunk is padded with zero-bytes if needed. Between sending each packet, and
acknowledgement is waited for before continuing. This is to ensure that the
comms system is not flooded. The splitting of the file into 25-byte chunks is
to make sure that the packets fit into the arduino's 60-byte RF buffer.
Finally, the command initiating the writing of the buffer is sent.

The shell takes the address of the serial bus as a command-line argument, under
Linux this is likely to be something of the form `\verb$/dev/ttyACMx$'.

\input{Vision}

Spinning and moving tends to move the grabbers about. To avoid this, the
grabbers are powered slightly during both of these actions. If the grabbers are
open, they are constantly opening while the robot is moving, albeit very
slowly. Likewise, the grabbers keep closing if they are already closed. For
this purpose, the robot maintains a local state variable for the grabber. It is
worth stating that this is not measured or sensed, so manually moving the
grabbers will confuse the robot.

\end{document}
