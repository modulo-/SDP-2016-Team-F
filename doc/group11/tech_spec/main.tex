\documentclass[a4paper,12pt]{scrartcl}
\author{Thomas Kerber, Marek Strelec}
\title{SDP Technical Specification}
\subtitle{Group 11}

\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{paralist,array}
\usepackage{listings}
\usepackage{float}
\usepackage{cleveref}
\lstset{language=Python, showstringspaces=false}

\begin{document}
\maketitle

\section{Introduction}

The aim of this project was to create a robot that would play a simplified
version of 2-a-side football. We used the provided Arduino Xino RF board and
LEGO pieces, a vision feed of the pitch, and computers to connect the two and
implement any further logic. This report will examine the decisions made in the
design of each part and their impacts. Furthermore it will explain the
principles our work relies on.

\input{overview}
\input{comms}
\input{arduino}

\section{Hardware Notes}

Grabbing the ball effectively is a fine balance of speed. Moving the grabbers
too quickly kicks the ball away. On the other hand, moving too slowly may lead
to missing the ball. Further, the design of the robot means that the ball must
be pushed in sharply to reset the kicker. The balance between these that was
found, is to close the grabbers at a moderate speed, then rapidly open them
part way and rapidly close them again. This resets the kicker, does not kick the ball away in most cases, and is fast enough to be usable.

Kicking the ball is a matter of speed, the faster we can kick, the less time
our opponents have to react. However, in order to kick, the ball must also be
positioned precicely in front of the kicker. To achieve this, the grabbers
rapidly push the ball into position again, correcting any drift from movement.
They open part-way, just enough for the kicker to kick without the ball
hitting the grabbers. Finally, the grabbers finish opening.

Spinning and moving tends to move the grabbers about. To avoid this, the
grabbers are powered slightly during both of these actions. If the grabbers are
open, they are constantly opening while the robot is moving, albeit very
slowly. Likewise, the grabbers keep closing if they are already closed. For
this purpose, the robot maintains a local state variable for the grabber. It is
worth stating that this is not measured or sensed, so manually moving the
grabbers will confuse the robot.

\input{Vision}

\section{Planning}

\subsection{Design}

The planner uses a system of goals and actions. Goals define an overall strategy in a given situation leading to a particular aim. Actions define one instruction given to the robot with preconditions for its execution. Goals are composed of a sequence of actions. A goal object selects the next action required to achieve its aim by traversing its ordered list of actions and evaluating their preconditions.

The planner makes its decision based only on the world state passed to it. This is described by an instance of the \emph{World} class passed to the planner. This object's state is updated by passing a new set of positions (as a dictionary of vectors) to the \texttt{update\_positions} method of \emph{World}. The \emph{World} class describes the state of the world from the vision, including position vectors for the robots, the ball and the goals. The \emph{World} class and its associated classes also provide methods on their data providing the planner with information about the world. Further utility functionality can be found in \emph{utils.py}.

The overall planner is used by calling \texttt{plan\_and\_act(world)}. This selects a goal based on the given world state  using its \texttt{get\_goal()} method. From this goal an action is generated using \texttt{generate\_action()}. The method then runs (using \texttt{actuate(action)} and returns a delay giving the time until the planner should be run again.

\subsection{Implementation}


Figure \ref{fig:receiveandpass} shows an example of Defender's goal \emph{ReceivingPass}. It shows a list of actions that are in a queue starting from the top. When action's preconditions are met, the action is executed and the process finishes. If any of the precondition is false, the next action in the queue is processed.

\begin{center}

\begin{figure}[H]
\centering
\begin{tabular}{ | l | p{110mm} | }
\hline
\textbf{Action} & \textbf{Preconditions} \\ \hline
GrabBall &
\begin{compactitem}
\item Defender can catch ball
\item Defender's grabbers are open
\end{compactitem}  \\ \hline

GoToStaticBall &
\begin{compactitem}
\item Defender is facing the catch point
\item Defender's grabbers are open
\item Ball is static
\end{compactitem}  \\ \hline

TurnToCatchPoint & 
\begin{compactitem}
\item Defender's grabbers are open
\end{compactitem}  \\ \hline

WaitForBallToCome &
\begin{compactitem}
\item Defender is facing ball
\item The ball can reach the robot
\item Defender can reach the ball
\item Grabbers are open
\item The ball is moving
\end{compactitem}  \\ \hline

FollowBall &
\begin{compactitem}
\item Defender's grabbers are open
\item The ball is moving
\end{compactitem}  \\ \hline

OpenGrabbers & 
\begin{compactitem}
\item Defender's grabbers are closed
\end{compactitem}  \\ \hline

FaceFriendly & 
\begin{compactitem}
\item Friendly is on the pitch
\end{compactitem}  \\ \hline
\end{tabular}
\par
\bigskip

\caption{ReceivingAndPass goal in the defender's planner. Shows actions and their corresponding preconditions that have to be satisfied.}

	\label{fig:receiveandpass}
\end{figure}



\end{center}

\subsection{Extensability}

Extending the planner is simply a case of adding goals and actions then adding the logic to select these in \texttt{select\_goal(world)}. Any new goals or actions should subclass Goal and Action respectively and override methods were stated.

In actions, the logic for performing should be placed in \texttt{perform(comms)}. This method is passed a \texttt{CommsManager} object through which the robot can be sent instructions. No more than one call should be made to this object in any given action. A new action should also override \texttt{get\_delay} giving an appropriate delay (in seconds) before the planner should run again. New actions can also have preconditions defined in a variable \texttt{preconditions}.

In goals, it may only be neccessary to write a Goal subclass with an ordered list of actions (from last to first). Otherwise the \texttt{generate\_action()} method can be overriden but similar logic should be followed.

\subsection{Integration}

An instance of the \texttt{Planner} is kept by the ``main.py'' script. Based on the delays given by the planner, it calls the planner at varying intervals, passing it the latest world model provided by the vision. The planner uses a \texttt{CommsManager} object to make control the robot.

\pagebreak
\appendix

\input{abi}
\input{llcmd}

\end{document}
