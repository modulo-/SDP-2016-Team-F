\section{Planning}
\lstset{language=Python, showstringspaces=false}

\subsection{Design}

The planner uses a system of goals and actions. Goals define an overall strategy in a given situation leading to a particular aim. Actions define one instruction given to the robot with preconditions for its execution. Goals are composed of a sequence of actions. A goal object selects the next action required to achieve its aim by traversing its ordered list of actions and evaluating their preconditions.

In the implementation, all goals and actions are derived from their respective super classes. These are defined as follows:

\begin{lstlisting}
class Goal(object):
    '''
    Base class for goals
    '''
    def __init__(self, world, robot):
        self.world = world
        self.robot = robot

    # Return the next action necesary to achieve the goal
    def generate_action(self):
        info("Generating action for goal: {0}"\
        	.format(self.__class__.__name__))
        for a in self.actions:
            if a.is_possible():
                return a
        return None


class Action(object):
    '''
    Base class for actions
    '''
    preconditions = []

    def __init__(self, world, robot, additional_preconds=[]):
        self.world = world
        self.robot = robot
        self.preconditions = self.__class__\
        	.preconditions + additional_preconds

    # Test the action's preconditions
    def is_possible(self):
        info("Testing action : {0}".format(self.__class__.__name__))
        for (condition, name) in self.preconditions:
            if not condition(self.world, self.robot):
                info("Precondition is false: {0}".format(name))
                return False
        info("Action possible: {0}".format(self.__class__.__name__))
        return True

    # Do comms to perform action
    def perform(self, comms):
        raise NotImplementedError

    # Get messages relating to action
    def get_messages(self):
        return []

    def get_delay(self):
        return DEFAULT_DELAY

\end{lstlisting}

The planner makes its decision based on only on the world state passed to it. This is described by an instance of the  class passed to the planner. This object's state is updated by passing a new set of positions (as a dictionary of vectors) to the \texttt{update\_positions} method of \texttt{World}. The \texttt{World} class describes the state of the world from the vision, including position vectors for the robots, the ball and the goals. The \texttt{World} class and its associated classes also provide methods on their data providing the planner with information about the world. Further utility functionality can be found in ``utils.py''

The overall planner is used by calling \texttt{plan\_and\_act(world)}.
This selects a goal based on the given world state  using its \texttt{get\_goal()} method. From this goal an action is generated using \texttt{generate\_action()}. The method then runs (using \texttt{actuate(action)}) and returns a delay giving the time until the planner should be run again.

\subsection{Implementation}

The attacker robot's goals and their respective actions are explained in \autoref{tbl:goals-actions}.
The planner chooses a goal based on ball position, as explained in \autoref{tbl:goals}.

\begin{table}[H]
\centering
\begin{tabularx}{\textwidth}{l l X}
\toprule
\textbf{Goal} & \textbf{Action} & \textbf{Preconditions} \\ 
\midrule

AttackPosition & TurnToDefenderToReceive & Attacker in score zone \\ 
&GoToScoreZone & Attacker is facing score zone  \\ 
&TurnToScoreZone & None \\
\midrule

Score & Shoot & Attacker has ball and attacker can score \\ 
& TurnToGoal & Attacker has ball \\ 
\midrule

GetBall & GrabBall & Attacker can catch ball and attacker's grabbers open \\ 
& GoToGrabStaticBall & Ball static, attacker facing ball, attacker's grabbers open \\ &OpenGrabbers & Ball in attacker's grab range, attacker's grabbers closed \\ 
&GoToBallOpeningDistance & Attacker is facing ball \\
&TurnToBall & None \\ 
\midrule

AttackerBlock & TurnToBlockingAngle & Attacker in blocking position \\ 
& GoToBlockingPosition & Attacker is facing blocking position \\ 
& TurnToFaceBlockingPosition & None \\ 
\bottomrule
\end{tabularx}
\caption{Actions and Preconditions by Goals}
\label{tbl:goals-actions}
\end{table}


\begin{table}[H]
\centering
\begin{tabular}{ l l}
\toprule
\textbf{Robot in possession} & \textbf{Goal} \\ \midrule
Our attacker & Score \\
Our defender & AttackPosition \\
Their attacker & AttackPosition \\
Their defender & AttackerBlock \\
Ball free & GetBall \\ \bottomrule
\end{tabular}
\caption{Goals chosen dependent on ball position}
\label{tbl:goals}
\end{table}

\subsection{Extensibility}

Extending the planner is simply a case of adding goals and actions then adding the logic to select these in \texttt{select\_goal(world)}. Any new goals or actions should subclass Goal and Action respectively and override methods were stated.

In actions, the logic for performing should be placed in \texttt{perform(comms)}. This method is passed a \texttt{CommsManager} object through which the robot can be sent instructions. No more than one call should be made to this object in any given action. A new action should also override \texttt{get\_delay} giving an appropriate delay (in seconds) before the planner should run again. New actions can also have preconditions defined in a variable \texttt{preconditions}.

In goals, it may only be neccessary to write a Goal subclass with an ordered list of actions (from last to first). Otherwise the \texttt{generate\_action()} method can be overriden but similar logic should be followed.

\subsection{Integration}

An instance of the \texttt{Planner} is kept by the ``main.py'' script. Based on the delays given by the planner, it calls the planner at varying intervals, passing it the latest world model provided by the vision. The planner uses a \texttt{CommsManager} object to make control the robot.

