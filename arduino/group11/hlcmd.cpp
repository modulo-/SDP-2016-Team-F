#include "hlcmd.h"
#include "llcmd.h"
#include "comms.h"
#include <stddef.h>
#include <string.h>
#include <Arduino.h>

#define cmdArg(cmd, offset, type) ((type *)((cmd) + (offset)))

namespace hlcmd {
    const uint8_t WAIT   = 0x00;
    const uint8_t BRAKE  = 0x01;
    const uint8_t STRAIT = 0x02;
    const uint8_t SPIN   = 0x03;
    const uint8_t KICK   = 0x04;
    const uint8_t MV     = 0x05;

    static uint16_t kickTimeFromDist(uint16_t dist) {
        if(dist >= 1500) {
            return 350;
        } else {
            uint32_t tmp = 9 * dist;
            tmp /= 250;
            return 170 + tmp;
        }
    }

    // Returns the length (command byte + argument lengths) required to validly
    // read the given HL command.
    size_t cmdRequiredLen(const uint8_t *cmd) {
        switch(*cmd) {
        case WAIT:
        case BRAKE:
        case STRAIT:
        case KICK:
            return 3;
        case MV:
            return 7;
        default:
            return 1;
        }
    }

    // Returns the length of the low-level commands generated by the given HL
    // command.
    size_t cmdCompiledLen(const uint8_t *cmd) {
        switch(*cmd) {
        case WAIT:
        case BRAKE:
            // 1-to-1 mapping
            return 3;
        case STRAIT:
            // An implicit 100ms brake
            return 6;
        case KICK:
            // 1. Extend
            // 2. Wait
            // 3. Retract
            // 4. Interruptable NOP
            return 10;
        case MV:
            // 1. Spin
            // 2. Brake
            // 3. Strait
            // 4. Brake
            // 5. Spin
            // 6. Brake
            return 18;
        default:
            return 0;
        }
    }

    // Compiles a command from in to out.
    void cmdCompile(const uint8_t *in, uint8_t *out) {
        switch(*in) {
        case WAIT:
            *out = llcmd::WAIT;
            memcpy(out + 1, in + 1, 2);
            break;
        case BRAKE:
            *out = llcmd::BRAKE;
            memcpy(out + 1, in + 1, 2);
            break;
        case STRAIT:
            out[0] = llcmd::STRAIT;
            memcpy(out + 1, in + 1, 2);
            out[3] = llcmd::BRAKE;
            *((uint16_t *)(out + 4)) = 100;
            break;
        case KICK:
            out[0] = llcmd::KICKER_EXTEND | llcmd::FLAG_UNINTERRUPTABLE;
            *((uint16_t *)(out + 1)) = kickTimeFromDist(
                *cmdArg(in, 1, uint16_t));
            out[3] = llcmd::WAIT | llcmd::FLAG_UNINTERRUPTABLE;
            *((uint16_t *)(out + 4)) = 100;
            out[6] = llcmd::KICKER_RETRACT | llcmd::FLAG_UNINTERRUPTABLE;
            *((uint16_t *)(out + 7)) = 270;
            out[9] = llcmd::NOP;
            break;
        case MV:
            // TODO
            // 1. Spin
            // 2. Brake
            // 3. Strait
            // 4. Brake
            // 5. Spin
            // 6. Brake
            memset(out, llcmd::NOP, 18);
            break;
        }
    }

    void process(const void *data, size_t len) {
        // Step 1: Find the sequence on uninterruptable commands, and move them
        // to the start of the command buffer. Interrupt interruptable
        // commands.
        if(llcmd::idle()) {
            llcmd::cmd_len = 0;
        } else {
            llcmd::cmd_len = llcmd::uninterruptableChainLen();
            if(llcmd::cmd_len == 0) {
                llcmd::finish(false);
            } else {
                memmove(llcmd::cmds, llcmd::cmds + llcmd::cmd_at,
                    llcmd::cmd_len);
            }
        }
        llcmd::cmd_at = 0;
        // Step 2: Compile the hl commands, one-by-one, into ll commands.
        const uint8_t *cmds = (const uint8_t *)data;
        size_t at = 0;
        while(at < len && at + cmdRequiredLen(&cmds[at]) <= len) {
            size_t len = cmdCompiledLen(&cmds[at]);
            if(llcmd::cmd_len + len > llcmd::cmd_cap) {
                const char *err = "Command buffer overflow. Discarding.";
                comms::send(err, 'e', strlen(err));
                break;
            }
            uint8_t bytecode[len];
            cmdCompile(&cmds[at], bytecode);
            memcpy(llcmd::cmds + llcmd::cmd_len, bytecode, len);
            llcmd::cmd_len += len;
            at += cmdRequiredLen(&cmds[at]);
        }
        llcmd::start();
    }
}
