#include "hlcmd.h"
#include "llcmd.h"
#include "comms.h"
#include <stddef.h>
#include <string.h>
#include <Arduino.h>
#include <math.h>

#define cmdArg(cmd, offset, type) ((type *)((cmd) + (offset)))

namespace hlcmd {
    const uint8_t WAIT          = 0x00;
    const uint8_t BRAKE         = 0x01;
    const uint8_t STRAIT        = 0x02;
    const uint8_t SPIN          = 0x03;
    const uint8_t KICK          = 0x04;
    const uint8_t MV            = 0x05;
    const uint8_t GRABBER_OPEN  = 0x06;
    const uint8_t GRABBER_CLOSE = 0x07;
    const uint8_t HOLD_SPIN     = 0x08;

    static uint16_t kickTimeFromDist(uint16_t dist) {
        if(dist >= 1500) {
            return 350;
        } else {
            uint32_t tmp = 9 * dist;
            tmp /= 250;
            return 170 + tmp;
        }
    }

    // Returns the length (command byte + argument lengths) required to validly
    // read the given HL command.
    size_t cmdRequiredLen(const uint8_t *cmd) {
        switch(*cmd) {
        case WAIT:
        case BRAKE:
        case STRAIT:
        case SPIN:
        case HOLD_SPIN:
        case KICK:
            return 3;
        case MV:
            return 13;
        case GRABBER_OPEN:
        case GRABBER_CLOSE:
        default:
            return 1;
        }
    }

    // Returns the length of the low-level commands generated by the given HL
    // command.
    size_t cmdCompiledLen(const uint8_t *cmd) {
        switch(*cmd) {
        case WAIT:
        case BRAKE:
            // 1-to-1 mapping
            return 3;
        case GRABBER_OPEN:
        case GRABBER_CLOSE:
        case KICK:
            // 1. Uninterruptable timed command
            // 2. Interruptable NOP.
            return 4;
        case STRAIT:
        case HOLD_SPIN:
        case SPIN:
            // An implicit 100ms brake
            return 6;
        case MV:
            // 1. Spin
            // 2. Brake
            // 3. Strait
            // 4. Brake
            // 5. Spin
            // 6. Brake
            return 18;
        default:
            return 0;
        }
    }

    static void compileMV(const uint8_t *in, uint8_t *out) {
        int32_t x = *cmdArg(in, 7, int16_t) - *cmdArg(in, 1, int16_t);
        int32_t y = *cmdArg(in, 9, int16_t) - *cmdArg(in, 3, int16_t);
        int32_t angle_strt = *cmdArg(in, 5, int16_t);
        int32_t angle_end = *cmdArg(in, 11, int16_t);
        int32_t mv_angle;
        if(x == 0 && y > 0) {
            mv_angle = 16200;
        } else if(x == 0) {
            mv_angle = 5400;
        } else {
            mv_angle = -atan2f(float(y), float(x)) * 10800 / M_PI;
        }
        mv_angle = (((mv_angle - angle_strt) % 21600) + 21600) % 21600;
        int16_t dist = (int16_t)sqrt(x*x + y*y);
        if(mv_angle > 10800) {
            mv_angle -= 21600;
        }
        if(mv_angle > 5400) {
            dist = -dist;
            mv_angle -= 10800;
        } else if(mv_angle < -5400) {
            dist = -dist;
            mv_angle += 10800;
        }
        int16_t face_angle = (((angle_end - mv_angle - angle_strt) % 21600)
            + 21600) % 21600;
        if(face_angle > 10800) {
            face_angle -= 21600;
        }
        // 1. Spin
        out[0] = llcmd::SPIN;
        *((int16_t *)(out + 1)) = mv_angle;
        // 2. Brake
        out[3] = llcmd::BRAKE;
        *((int16_t *)(out + 4)) = 100;
        // 3. Strait
        out[6] = llcmd::STRAIT;
        *((int16_t *)(out + 7)) = dist;
        // 4. Brake
        out[9] = llcmd::BRAKE;
        *((int16_t *)(out + 10)) = 100;
        // 5. Spin
        out[12] = llcmd::SPIN;
        *((int16_t *)(out + 13)) = face_angle;
        // 6. Brake
        out[15] = llcmd::BRAKE;
        *((int16_t *)(out + 16)) = 100;
    }

    // Compiles a command from in to out.
    void cmdCompile(const uint8_t *in, uint8_t *out) {
        switch(*in) {
        case WAIT:
            *out = llcmd::WAIT;
            memcpy(out + 1, in + 1, 2);
            break;
        case BRAKE:
            *out = llcmd::BRAKE;
            memcpy(out + 1, in + 1, 2);
            break;
        case STRAIT:
            out[0] = llcmd::STRAIT;
            memcpy(out + 1, in + 1, 2);
            out[3] = llcmd::BRAKE;
            *((uint16_t *)(out + 4)) = 100;
            break;
        case KICK:
            out[0] = llcmd::KICK | llcmd::FLAG_UNINTERRUPTABLE;
            memcpy(out + 1, in + 1, 2);
            out[3] = llcmd::NOP;
            break;
        case HOLD_SPIN:
            out[0] = llcmd::HOLD_SPIN;
            memcpy(out + 1, in + 1, 2);
            out[3] = llcmd::BRAKE;
            *((uint16_t *)(out + 4)) = 100;
            break;
        case SPIN:
            out[0] = llcmd::SPIN;
            memcpy(out + 1, in + 1, 2);
            out[3] = llcmd::BRAKE;
            *((uint16_t *)(out + 4)) = 100;
            break;
        case MV:
            compileMV(in, out);
            break;
        case GRABBER_OPEN:
            out[0] = llcmd::GRABBER_OPEN | llcmd::FLAG_UNINTERRUPTABLE;
            *((uint16_t *)(out + 1)) = 600;
            out[3] = llcmd::NOP;
            break;
        case GRABBER_CLOSE:
            out[0] = llcmd::GRABBER_CLOSE | llcmd::FLAG_UNINTERRUPTABLE;
            *((uint16_t *)(out + 1)) = 600;
            out[3] = llcmd::NOP;
            break;
        }
    }

    void process(const void *data, size_t len) {
        // Step 1: Find the sequence on uninterruptable commands, and move them
        // to the start of the command buffer. Interrupt interruptable
        // commands.
        if(llcmd::idle()) {
            llcmd::cmd_len = 0;
        } else {
            llcmd::cmd_len = llcmd::uninterruptableChainLen();
            if(llcmd::cmd_len == 0) {
                llcmd::finish(false);
            } else {
                memmove(llcmd::cmds, llcmd::cmds + llcmd::cmd_at,
                    llcmd::cmd_len);
            }
        }
        llcmd::cmd_at = 0;
        // Step 2: Compile the hl commands, one-by-one, into ll commands.
        const uint8_t *cmds = (const uint8_t *)data;
        size_t at = 0;
        while(at < len && at + cmdRequiredLen(&cmds[at]) <= len) {
            size_t len = cmdCompiledLen(&cmds[at]);
            if(llcmd::cmd_len + len > llcmd::cmd_cap) {
                const char *err = "Command buffer overflow. Discarding.";
                comms::send(err, 'e', strlen(err));
                break;
            }
            uint8_t bytecode[len];
            cmdCompile(&cmds[at], bytecode);
            memcpy(llcmd::cmds + llcmd::cmd_len, bytecode, len);
            llcmd::cmd_len += len;
            at += cmdRequiredLen(&cmds[at]);
        }
        llcmd::start();
    }
}
